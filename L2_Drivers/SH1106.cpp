/*
 * SH1106.cpp
 *
 *  Created on: Aug 10, 2018
 *      Author: rehanashraf
 */

#include "SH1106.h"

typedef enum
{
    HORIZONTAL = 0,
    VERTICAL,
    PAGE,
    INVALID,
    END_MEMORY_ADDRESSING_MODES
} MEMORY_ADDRESSING_MODES;

int length = SH1106_LCDWIDTH*SH1106_LCDHEIGHT/8;
#define SH1106_swap(a, b) { int16_t t = a; a = b; b = t; }

static uint8_t buffer[SH1106_LCDHEIGHT * SH1106_LCDWIDTH / 8] = {
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0xC0,
	    0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0x80, 0x80, 0x18, 0x18, 0x18, 0x38, 0x38,
	    0x3C, 0x3C, 0x7C, 0x7C, 0x7C, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x02, 0x02, 0x02, 0x06,
	    0x06, 0x1F, 0x1F, 0x1F, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF, 0x1F, 0x1F, 0x03, 0x03, 0x03, 0x80, 0x80,
	    0x01, 0x01, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0x7E, 0x7E, 0x7E, 0x3E, 0x3E, 0x1E, 0x1E, 0x1E, 0x06,
	    0x06, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0x70, 0x70,
	    0x30, 0x30, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x20, 0x20, 0x30, 0x30, 0x30, 0x78, 0x78, 0x7C, 0x7C, 0x7C, 0xF9, 0xF9, 0xE3, 0xE3, 0xE3, 0x83,
	    0x83, 0x07, 0x07, 0x07, 0x07, 0x07, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0x88, 0x88, 0x88, 0x80, 0x80,
	    0x00, 0x00, 0x78, 0x78, 0x78, 0xB8, 0xB8, 0x91, 0x91, 0x91, 0xC0, 0xC0, 0xD0, 0xD0, 0xD0, 0xEF,
	    0xEF, 0xEE, 0xEE, 0xEE, 0xEC, 0xEC, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0x66, 0x66, 0x66, 0x67, 0x67,
	#if (SH1106_LCDHEIGHT * SH1106_LCDWIDTH > 96 * 16)
	    0x6E, 0x6E, 0x60, 0x60, 0x60, 0xE0, 0xE0, 0xE8, 0xE8, 0xE8, 0xCC, 0xCC, 0xDF, 0xDF, 0xDF, 0xC0,
	    0xC0, 0xA0, 0xA0, 0xA0, 0x33, 0x33, 0x71, 0x71, 0x71, 0x78, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x38, 0x38, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x1F, 0x1F, 0x1F, 0x0F, 0x0F, 0x8F, 0x8F, 0x8F, 0xC4,
	    0xC4, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04,
	    0xCE, 0xCE, 0xEF, 0xEF, 0xEF, 0x7F, 0x7F, 0x3F, 0x3F, 0x3F, 0x1F, 0x1F, 0x0F, 0x0F, 0x0F, 0x0F,
	    0x0F, 0x07, 0x07, 0x07, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
	    0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x0E, 0x0E, 0x0E, 0x0C, 0x0C, 0x1C, 0x1C, 0x1C, 0x19,
	    0x19, 0x39, 0x39, 0x39, 0x73, 0x73, 0xE7, 0xE7, 0xE7, 0x8E, 0x8E, 0x1D, 0x1D, 0x1D, 0x73, 0x73,
	    0xE7, 0xE7, 0x03, 0x03, 0x03, 0x60, 0x60, 0xE4, 0xE4, 0xE4, 0x66, 0x66, 0x27, 0x27, 0x27, 0x87,
	    0x87, 0x87, 0x87, 0x87, 0xC7, 0xC7, 0xE7, 0xE7, 0xE7, 0xF7, 0xF7, 0xF0, 0xF0, 0xF0, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xF8, 0xF8, 0xF8, 0x7F, 0x7F,
	    0x3F, 0x3F, 0x31, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x10, 0x10, 0x90, 0x90, 0x90, 0x90,
	    0x90, 0xD0, 0xD0, 0xD0, 0xF0, 0xF0, 0x78, 0x78, 0x78, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0,
	    0x01, 0x01, 0x3F, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x5D, 0x5D, 0x5D, 0x49,
	    0x49, 0xC9, 0xC9, 0xC9, 0xE1, 0xE1, 0xE3, 0xE3, 0xE3, 0xE3, 0xE3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3,
	#if (SH1106_LCDHEIGHT == 64)
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x3F, 0x3F, 0x3F, 0x1F, 0x1F, 0x01, 0x01, 0x01, 0xC0, 0xC0,
	    0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01,
	    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 0x1C, 0x1C, 0x3F, 0x3F, 0x3F, 0x77, 0x77,
	    0xC0, 0xC0, 0x80, 0x80, 0x80, 0x00, 0x00, 0x03, 0x03, 0x03, 0x13, 0x13, 0x33, 0x33, 0x33, 0x72,
	    0x72, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF1, 0xF1, 0xF1, 0x7B, 0x7B, 0x0B, 0x0B, 0x0B, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0xFF, 0xFF,
	    0x3F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0xC0,
	    0xC0, 0xC0, 0xC0, 0xC0, 0xE0, 0xE0, 0x60, 0x60, 0x60, 0x70, 0x70, 0x70, 0x70, 0x70, 0x38, 0x38,
	    0x3C, 0x3C, 0x1F, 0x1F, 0x1F, 0x07, 0x07, 0x80, 0x80, 0x80, 0x80, 0x80, 0x86, 0x86, 0x86, 0x8C,
	    0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C, 0x8C,
	    0x8D, 0x8D, 0x8F, 0x8F, 0x8F, 0x9F, 0x9F, 0x9E, 0x9E, 0x9E, 0x9C, 0x9C, 0x18, 0x18, 0x18, 0x10,
	    0x10, 0x20, 0x20, 0x20, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x1E, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F,
	    0x86, 0x86, 0xC7, 0xC7, 0xC7, 0xE3, 0xE3, 0x63, 0x63, 0x63, 0xB1, 0xB1, 0xB9, 0xB9, 0xB9, 0xD9,
	    0xD9, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x63, 0x63,
	    0x23, 0x23, 0x33, 0x33, 0x33, 0x33, 0x33, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
	    0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,
	    0x31, 0x31, 0x35, 0x35, 0x35, 0x3F, 0x3F, 0x2F, 0x2F, 0x2F, 0x39, 0x39, 0x78, 0x78, 0x78, 0x70,
	    0x70, 0x60, 0x60, 0x60, 0xC0, 0xC0, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x60, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x18, 0x1C, 0x1C, 0x0E, 0x0E, 0x0E, 0x0F, 0x0F,
	    0x07, 0x07, 0x06, 0x06, 0x06, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#endif
#endif
};
static uint8_t adafruit_buffer[SH1106_LCDHEIGHT * SH1106_LCDWIDTH / 8] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
#if (SH1106_LCDHEIGHT * SH1106_LCDWIDTH > 96*16)
0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#if (SH1106_LCDHEIGHT == 64)
0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,
0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,
0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00,
0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E,
0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC,
0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06,
0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8,
0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00,
0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C,
0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F,
0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00,
0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07,
0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#endif
#endif
};

SH1106::SH1106(GPIO *DC, GPIO *RST, GPIO *CS) : GFX(SH1106_LCDWIDTH, SH1106_LCDHEIGHT)
{
	dc = DC;
	rst = RST;
	cs = CS;
	_vccstate = 0;
#ifdef USING_SW_SPI
	mosi= NULL;
	clk = NULL;
#endif
}
#ifdef USING_SW_SPI
SH1106::SH1106(GPIO *DC, GPIO *RST, GPIO *CS, GPIO *CLK, GPIO *MOSI)
{
	dc = DC;
	rst = RST;
	cs = CS;
	clk = CLK;
	mosi = MOSI;
	_vccstate = 0;

}
#endif
void SH1106::init(uint8_t vccstate)
{
	/* Set Data Command, Chip Select and Reset as Output */
	rst->setAsOutput();
	dc->setAsOutput();
	cs->setAsOutput();

	/* Initialize SPI or if using Software SPI as mosi and clk as output pins*/
#ifndef USING_SW_SPI
    ssp1_init();
#endif
#ifdef USING_SW_SPI
		mosi->setAsOutput();
		clk->setAsOutput();
#endif

    /* Need to set reset high, wait, low, and high again to initiate Init Sequence*/
    rst->setHigh();		// VDD (3.3V) goes high at start, lets just chill for a ms
    delay_ms(1);
    rst->setLow();		// bring reset low
    // wait 10ms
    delay_ms(10);
    // bring out of reset
    rst->setHigh();
    // turn on VCC (9V?)

    // Init sequence
     sh1106_command(SH1106_DISPLAYOFF);                    // 0xAE
     sh1106_command(SH1106_SETDISPLAYCLOCKDIV);            // 0xD5

     #if defined SH1106_128_64
       // Init sequence for 128x64 OLED module
       sh1106_command(0xF0);                                 // the suggested ratio 0xF0 XXXXXXXX
       sh1106_command(SH1106_SETMULTIPLEX);                  // 0xA8 XXXXXXXXX
       sh1106_command(0x3F);								   // XXXXXXXXXXX
       sh1106_command(SH1106_OUTPUT_FOLLOWS_RAM);            // 0xA4 XXXXXXXXX
       sh1106_command(SH1106_SETDISPLAYOFFSET);              // 0xD3 XXXXXXXXX
       sh1106_command(0x0);                                  // no offset  XXXXXXXXX
       sh1106_command(SH1106_SETSTARTLINE | 0x0);            // line #0
       sh1106_command(SH1106_CHARGEPUMP);                    // 0x8D XXXXXXXXXX
       if (vccstate == SH1106_EXTERNALVCC)					   // XXXXXXXXX
         { sh1106_command(0x10); }						   // XXXXXXXXX
       else												   // XXXXXXXXX
         { sh1106_command(0x14); }						   // XXXXXXXXX
       sh1106_command(SH1106_MEMORYMODE);                    // 0x20 XXXXXXXXXXXXXX
   //    sh1106_command(PAGE);                                  // 0x2 Paged XXXXXXXXXXX
       sh1106_command(HORIZONTAL);                                  // 0x0 Horizontal XXXXXXXXXXX
       sh1106_command(SH1106_SET_PAGE_ADDRESS); 			// start at page address 0 XXXXXXXXX
   //    sh1106_command(SH1106_SEGREMAP | 0x1);				   // ?????????????
       sh1106_command(SH1106_COMSCANDEC);					   // XXXXXXXXXX
       sh1106_command(SH1106_SETLOWCOLUMN);				   // XXXXXXXXXX
       sh1106_command(SH1106_SETHIGHCOLUMN);				   // XXXXXXXXXX
       sh1106_command(SH1106_SETCOMPINS);                    // 0xDA XXXXXXXXX
       sh1106_command(0x12);								   // XXXXXXXXXX
       sh1106_command(SH1106_SETCONTRAST);                   // 0x81 XXXXXXXX
       if (vccstate == SH1106_EXTERNALVCC)					   // XXXXXXX
         { sh1106_command(0x9F); }						   // XXXXXXX
       else					   							   // XXXXXXX
         { sh1106_command(0xCF); }					       // XXXXXXX
       sh1106_command(SH1106_SET_SEGMENT_REMAP);             // 0xA1 XXXXXXXX
       sh1106_command(SH1106_SETPRECHARGE);                  // 0xd9 XXXXXXXXX
       if (vccstate == SH1106_EXTERNALVCC)					   // XXXXXXXXX
         { sh1106_command(0x22); }						   // XXXXXXXXX
       else												   // XXXXXXXXX
         { sh1106_command(0xF1); }						   // XXXXXXXXX
       sh1106_command(SH1106_SETVCOMDETECT);                 // 0xDB XXXXXXXX
       sh1106_command(0x20);								   // 0.77xVcc XXXXXXX
       sh1106_command(SH1106_DISPLAYALLON_RESUME);           // 0xA4 XXXXXXXXXX
       sh1106_command(SH1106_NORMALDISPLAY);                 // 0xA6  XXXXXXXXXX
     #endif

     sh1106_command(SH1106_DISPLAYON);	//--turn on oled panel
}
void SH1106::sh1106_command(uint8_t c)
{
	cs->setHigh();					/* Make sure that chip select is high */
	dc->setLow();					/* Pull DC to low */
	cs->setLow();					/* Pull Chip select to low */
#ifndef USING_SW_SPI
	ssp1_exchange_byte(c);			/* Send data on HW spi */
	cs->setHigh();					/* Set Chip Select high again */
#endif
#ifdef USING_SW_SPI
	fastSPIwrite(c);				/* Send data on SW spi */
	cs->setHigh();					/* Set Chip Select high again */
	return;
#endif


}
void SH1106::setAdafruitDisplay(void)
{
	for (int i = 0; i < length; i++)
	{
		buffer[i]=adafruit_buffer[i];
	}
}

void SH1106::display(void) {
	   for (int page = 0; page < SH1106_MAX_PAGE_COUNT; page++)
	    {
			sh1106_command(SH1106_SET_PAGE_ADDRESS + page);
	        sh1106_command(0x02); // low column start address
	        sh1106_command(0x10); // high column start address
	        for (int pixel = 0; pixel < SH1106_LCDWIDTH; pixel++)
	        {
	        	cs->setHigh();
	        	dc->setHigh();
	        	cs->setLow();
#ifndef USING_SW_SPI
	        	ssp1_exchange_byte(buffer[(page << 7) + pixel]);
#endif

	        	cs->setHigh();

			}
	    }
}

void SH1106::clearDisplay(void) {
  memset(buffer, 0, length);
  /* Same implementation using for loop */
/*  for (int i = 0; i < length; i++)
  {
	  buffer[i]= 0;
  }*/
}

void SH1106::invertDisplay(uint8_t i) {
  if (i) {
    sh1106_command(SH1106_INVERTDISPLAY);
  } else {
    sh1106_command(SH1106_NORMALDISPLAY);
  }
}


// startscrollright
// Activate a right handed scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void SH1106::startscrollright(uint8_t start, uint8_t stop){
  sh1106_command(SH1106_RIGHT_HORIZONTAL_SCROLL);
  sh1106_command(0X00);
  sh1106_command(start);
  sh1106_command(0X00);
  sh1106_command(stop);
  sh1106_command(0X00);
  sh1106_command(0XFF);
  sh1106_command(SH1106_ACTIVATE_SCROLL);
}

// startscrollleft
// Activate a right handed scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void SH1106::startscrollleft(uint8_t start, uint8_t stop){
  sh1106_command(SH1106_LEFT_HORIZONTAL_SCROLL);
  sh1106_command(0X00);
  sh1106_command(start);
  sh1106_command(0X00);
  sh1106_command(stop);
  sh1106_command(0X00);
  sh1106_command(0XFF);
  sh1106_command(SH1106_ACTIVATE_SCROLL);
}

// startscrolldiagright
// Activate a diagonal scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void SH1106::startscrolldiagright(uint8_t start, uint8_t stop){
  sh1106_command(SH1106_SET_VERTICAL_SCROLL_AREA);
  sh1106_command(0X00);
  sh1106_command(SH1106_LCDHEIGHT);
  sh1106_command(SH1106_VERTICAL_AND_RIGHT_HORIZONTAL_SCROLL);
  sh1106_command(0X00);
  sh1106_command(start);
  sh1106_command(0X00);
  sh1106_command(stop);
  sh1106_command(0X01);
  sh1106_command(SH1106_ACTIVATE_SCROLL);
}

// startscrolldiagleft
// Activate a diagonal scroll for rows start through stop
// Hint, the display is 16 rows tall. To scroll the whole display, run:
// display.scrollright(0x00, 0x0F)
void SH1106::startscrolldiagleft(uint8_t start, uint8_t stop){
  sh1106_command(SH1106_SET_VERTICAL_SCROLL_AREA);
  sh1106_command(0X00);
  sh1106_command(SH1106_LCDHEIGHT);
  sh1106_command(SH1106_VERTICAL_AND_LEFT_HORIZONTAL_SCROLL);
  sh1106_command(0X00);
  sh1106_command(start);
  sh1106_command(0X00);
  sh1106_command(stop);
  sh1106_command(0X01);
  sh1106_command(SH1106_ACTIVATE_SCROLL);
}

void SH1106::stopscroll(void){
  sh1106_command(SH1106_DEACTIVATE_SCROLL);
}

inline void SH1106::fastSPIwrite(uint8_t d) {
	/* This is for Software SPI implementation */

}

// Dim the display
// dim = true: display is dimmed
// dim = false: display is normal
void SH1106::dim(boolean dim) {
  uint8_t contrast;

  if (dim) {
    contrast = 0; // Dimmed display
  } else {
    if (_vccstate == SH1106_EXTERNALVCC) {
      contrast = 0x9F;
    } else {
      contrast = 0xCF;
    }
  }
  // the range of contrast to too small to be really useful
  // it is useful to dim the display
  sh1106_command(SH1106_SETCONTRAST);
  sh1106_command(contrast);
}
void SH1106::drawPixel(int16_t x, int16_t y, uint16_t color) {
  if ((x < 0) || (x >= width()) || (y < 0) || (y >= height()))
    return;

  // check rotation, move pixel around if necessary
  switch (getRotation()) {
  case 1:
    SH1106_swap(x, y);
    x = WIDTH - x - 1;
    break;
  case 2:
    x = WIDTH - x - 1;
    y = HEIGHT - y - 1;
    break;
  case 3:
    SH1106_swap(x, y);
    y = HEIGHT - y - 1;
    break;
  }

  // x is which column
    switch (color)
    {
      case WHITE:   buffer[x+ (y/8)*SH1106_LCDWIDTH] |=  (1 << (y&7)); break;
      case BLACK:   buffer[x+ (y/8)*SH1106_LCDWIDTH] &= ~(1 << (y&7)); break;
      case INVERSE: buffer[x+ (y/8)*SH1106_LCDWIDTH] ^=  (1 << (y&7)); break;
    }

}

#ifdef GFX_IMPLEMENTED
void SH1106::drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) {
  boolean bSwap = false;
  switch(rotation) {
    case 0:
      // 0 degree rotation, do nothing
      break;
    case 1:
      // 90 degree rotation, swap x & y for rotation, then invert x
      bSwap = true;
      SH1106_swap(x, y);
      x = WIDTH - x - 1;
      break;
    case 2:
      // 180 degree rotation, invert x and y - then shift y around for height.
      x = WIDTH - x - 1;
      y = HEIGHT - y - 1;
      x -= (w-1);
      break;
    case 3:
      // 270 degree rotation, swap x & y for rotation, then invert y  and adjust y for w (not to become h)
      bSwap = true;
      SH1106_swap(x, y);
      y = HEIGHT - y - 1;
      y -= (w-1);
      break;
  }

  if(bSwap) {
    drawFastVLineInternal(x, y, w, color);
  } else {
    drawFastHLineInternal(x, y, w, color);
  }
}

void SH1106::drawFastHLineInternal(int16_t x, int16_t y, int16_t w, uint16_t color) {
  // Do bounds/limit checks
  if(y < 0 || y >= HEIGHT) { return; }

  // make sure we don't try to draw below 0
  if(x < 0) {
    w += x;
    x = 0;
  }

  // make sure we don't go off the edge of the display
  if( (x + w) > WIDTH) {
    w = (WIDTH - x);
  }

  // if our width is now negative, punt
  if(w <= 0) { return; }

  // set up the pointer for  movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SH1106_LCDWIDTH);
  // and offset x columns in
  pBuf += x;

  register uint8_t mask = 1 << (y&7);

  switch (color)
  {
  case WHITE:         while(w--) { *pBuf++ |= mask; }; break;
    case BLACK: mask = ~mask;   while(w--) { *pBuf++ &= mask; }; break;
  case INVERSE:         while(w--) { *pBuf++ ^= mask; }; break;
  }
}

void SH1106::drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
  bool bSwap = false;
  switch(rotation) {
    case 0:
      break;
    case 1:
      // 90 degree rotation, swap x & y for rotation, then invert x and adjust x for h (now to become w)
      bSwap = true;
      SH1106_swap(x, y);
      x = WIDTH - x - 1;
      x -= (h-1);
      break;
    case 2:
      // 180 degree rotation, invert x and y - then shift y around for height.
      x = WIDTH - x - 1;
      y = HEIGHT - y - 1;
      y -= (h-1);
      break;
    case 3:
      // 270 degree rotation, swap x & y for rotation, then invert y
      bSwap = true;
      SH1106_swap(x, y);
      y = HEIGHT - y - 1;
      break;
  }

  if(bSwap) {
    drawFastHLineInternal(x, y, h, color);
  } else {
    drawFastVLineInternal(x, y, h, color);
  }
}


void SH1106::drawFastVLineInternal(int16_t x, int16_t __y, int16_t __h, uint16_t color) {

  // do nothing if we're off the left or right side of the screen
  if(x < 0 || x >= WIDTH) { return; }

  // make sure we don't try to draw below 0
  if(__y < 0) {
    // __y is negative, this will subtract enough from __h to account for __y being 0
    __h += __y;
    __y = 0;

  }

  // make sure we don't go past the height of the display
  if( (__y + __h) > HEIGHT) {
    __h = (HEIGHT - __y);
  }

  // if our height is now negative, punt
  if(__h <= 0) {
    return;
  }

  // this display doesn't need ints for coordinates, use local byte registers for faster juggling
  register uint8_t y = __y;
  register uint8_t h = __h;


  // set up the pointer for fast movement through the buffer
  register uint8_t *pBuf = buffer;
  // adjust the buffer pointer for the current row
  pBuf += ((y/8) * SH1106_LCDWIDTH);
  // and offset x columns in
  pBuf += x;

  // do the first partial byte, if necessary - this requires some masking
  register uint8_t mod = (y&7);
  if(mod) {
    // mask off the high n bits we want to set
    mod = 8-mod;

    // note - lookup table results in a nearly 10% performance improvement in fill* functions
    // register uint8_t mask = ~(0xFF >> (mod));
    static uint8_t premask[8] = {0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };
    register uint8_t mask = premask[mod];

    // adjust the mask if we're not going to reach the end of this byte
    if( h < mod) {
      mask &= (0XFF >> (mod-h));
    }

  switch (color)
    {
    case WHITE:   *pBuf |=  mask;  break;
    case BLACK:   *pBuf &= ~mask;  break;
    case INVERSE: *pBuf ^=  mask;  break;
    }

    // fast exit if we're done here!
    if(h<mod) { return; }

    h -= mod;

    pBuf += SH1106_LCDWIDTH;
  }


  // write solid bytes while we can - effectively doing 8 rows at a time
  if(h >= 8) {
    if (color == INVERSE)  {          // separate copy of the code so we don't impact performance of the black/white write version with an extra comparison per loop
      do  {
      *pBuf=~(*pBuf);

        // adjust the buffer forward 8 rows worth of data
        pBuf += SH1106_LCDWIDTH;

        // adjust h & y (there's got to be a faster way for me to do this, but this should still help a fair bit for now)
        h -= 8;
      } while(h >= 8);
      }
    else {
      // store a local value to work with
      register uint8_t val = (color == WHITE) ? 255 : 0;

      do  {
        // write our value in
      *pBuf = val;

        // adjust the buffer forward 8 rows worth of data
        pBuf += SH1106_LCDWIDTH;

        // adjust h & y (there's got to be a faster way for me to do this, but this should still help a fair bit for now)
        h -= 8;
      } while(h >= 8);
      }
    }

  // now do the final partial byte, if necessary
  if(h) {
    mod = h & 7;
    // this time we want to mask the low bits of the byte, vs the high bits we did above
    // register uint8_t mask = (1 << mod) - 1;
    // note - lookup table results in a nearly 10% performance improvement in fill* functions
    static uint8_t postmask[8] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F };
    register uint8_t mask = postmask[mod];
    switch (color)
    {
      case WHITE:   *pBuf |=  mask;  break;
      case BLACK:   *pBuf &= ~mask;  break;
      case INVERSE: *pBuf ^=  mask;  break;
    }
  }
}
#endif

SH1106::~SH1106() {
	// TODO Auto-generated destructor stub
}

